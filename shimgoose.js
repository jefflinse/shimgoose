const mongoose = require('mongoose');
const applyWriteConcern = require('./node_modules/mongoose/lib/helpers/schema/applyWriteConcern');

function wrapModel(model) {
  mongoose.Model.prototype.$__handleSave = function(options, callback) {
    const _this = this;
    let saveOptions = {};
  
    applyWriteConcern(this.$__schema, options);
    if (typeof options.writeConcern !== 'undefined') {
      saveOptions.writeConcern = {};
      if ('w' in options.writeConcern) {
        saveOptions.writeConcern.w = options.writeConcern.w;
      }
      if ('j' in options.writeConcern) {
        saveOptions.writeConcern.j = options.writeConcern.j;
      }
      if ('wtimeout' in options.writeConcern) {
        saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
      }
    } else {
      if ('w' in options) {
        saveOptions.w = options.w;
      }
      if ('j' in options) {
        saveOptions.j = options.j;
      }
      if ('wtimeout' in options) {
        saveOptions.wtimeout = options.wtimeout;
      }
    }
    if ('checkKeys' in options) {
      saveOptions.checkKeys = options.checkKeys;
    }
    const session = this.$session();
    if (!saveOptions.hasOwnProperty('session')) {
      saveOptions.session = session;
    }
  
    if (Object.keys(saveOptions).length === 0) {
      saveOptions = null;
    }
    if (this.$isNew) {
      // send entire doc
      // SHIM
      const obj = this.toObject();
      // const obj = this.toObject(saveToObjectOptions);
      if ((obj || {})._id === void 0) {
        // documents must have an _id else mongoose won't know
        // what to update later if more changes are made. the user
        // wouldn't know what _id was generated by mongodb either
        // nor would the ObjectId generated by mongodb necessarily
        // match the schema definition.
        immediate(function() {
          callback(new MongooseError('document must have an _id before saving'));
        });
        return;
      }
  
      this.$__version(true, obj);

      // SHIM
      // this[modelCollectionSymbol].insertOne(obj, saveOptions, function(err, ret) {
      //   if (err) {
      //     _setIsNew(_this, true);
  
      //     callback(err, null);
      //     return;
      //   }
  
      //   callback(null, ret);
      // });
      console.log("faking INSERT");
      callback(null, {
        insertedCount: 1,
        ops: [{
          _id: obj._id,
          ...obj
        }]
      });

      this.$__reset();
      _setIsNew(this, false);
      // Make it possible to retry the insert
      this.$__.inserting = true;
    } else {
      // Make sure we don't treat it as a new object on error,
      // since it already exists
      this.$__.inserting = false;
  
      const delta = this.$__delta();
      if (delta) {
        if (delta instanceof MongooseError) {
          callback(delta);
          return;
        }
  
        const where = this.$__where(delta[0]);
        if (where instanceof MongooseError) {
          callback(where);
          return;
        }
  
        _applyCustomWhere(this, where);
        this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret) => {
          if (err) {
            this.$__undoReset();
  
            callback(err);
            return;
          }
          ret.$where = where;
          callback(null, ret);
        });
      } else {
        const optionsWithCustomValues = Object.assign({}, options, saveOptions);
        const where = this.$__where();
        if (this.$__schema.options.optimisticConcurrency) {
          const key = this.$__schema.options.versionKey;
          const val = this.$__getValue(key);
          if (val != null) {
            where[key] = val;
          }
        }
        this.constructor.exists(where, optionsWithCustomValues)
          .then(documentExists => {
            const matchedCount = !documentExists ? 0 : 1;
            callback(null, { $where: where, matchedCount });
          })
          .catch(callback);
        return;
      }
  
      // store the modified paths before the document is reset
      this.$__.modifiedPaths = this.modifiedPaths();
      this.$__reset();
  
      _setIsNew(this, false);
    }
  };

  return model
}

function _setIsNew(doc, val) {
  doc.$isNew = val;
  doc.$emit('isNew', val);
  doc.constructor.emit('isNew', val);

  const subdocs = doc.$getAllSubdocs();
  for (const subdoc of subdocs) {
    subdoc.$isNew = val;
  }
}

module.exports = {
  wrapModel,
};
