const mongoose = require('mongoose');
const applyWriteConcern = require('./node_modules/mongoose/lib/helpers/schema/applyWriteConcern');

mongoose.Model.prototype.$__handleSave = function(options, callback) {
  const _this = this;

  if (this.$isNew) {
    const obj = this.toObject();
    if ((obj || {})._id === void 0) {
      // documents must have an _id else mongoose won't know
      // what to update later if more changes are made. the user
      // wouldn't know what _id was generated by mongodb either
      // nor would the ObjectId generated by mongodb necessarily
      // match the schema definition.
      immediate(function() {
        callback(new MongooseError('document must have an _id before saving'));
      });
      return;
    }

    this.$__version(true, obj);

    console.log("faking INSERT");
    callback(null, {
      insertedCount: 1,
      ops: [{
        _id: obj._id,
        ...obj
      }]
    });

    this.$__reset();
    _setIsNew(this, false);
    // Make it possible to retry the insert
    this.$__.inserting = true;
  } else {
    // Make sure we don't treat it as a new object on error,
    // since it already exists
    this.$__.inserting = false;

    const delta = this.$__delta();
    if (delta) {
      if (delta instanceof MongooseError) {
        callback(delta);
        return;
      }

      const where = this.$__where(delta[0]);
      if (where instanceof MongooseError) {
        callback(where);
        return;
      }

      _applyCustomWhere(this, where);
      console.log("faking UPDATE");
      callback(null, {
        matchedCount: 1,
        modifiedCount: 1,
        upsertedCount: 0,
        ops: [{
          _id: this._id,
          ...delta[0]
        }]
      });
    } else {
      const optionsWithCustomValues = Object.assign({}, options, null);
      const where = this.$__where();
      if (this.$__schema.options.optimisticConcurrency) {
        const key = this.$__schema.options.versionKey;
        const val = this.$__getValue(key);
        if (val != null) {
          where[key] = val;
        }
      }
      this.constructor.exists(where, optionsWithCustomValues)
        .then(documentExists => {
          const matchedCount = !documentExists ? 0 : 1;
          callback(null, { $where: where, matchedCount });
        })
        .catch(callback);
      return;
    }

    // store the modified paths before the document is reset
    this.$__.modifiedPaths = this.modifiedPaths();
    this.$__reset();

    _setIsNew(this, false);
  }
};


function _setIsNew(doc, val) {
  doc.$isNew = val;
  doc.$emit('isNew', val);
  doc.constructor.emit('isNew', val);

  const subdocs = doc.$getAllSubdocs();
  for (const subdoc of subdocs) {
    subdoc.$isNew = val;
  }
}

module.exports = {};
