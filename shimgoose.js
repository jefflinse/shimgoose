const mongoose = require('mongoose');
const applyGlobalMaxTimeMS = require('./node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS');
const wrapThunk = require('./node_modules/mongoose/lib/helpers/query/wrapThunk');

mongoose.Query.prototype._findOne = wrapThunk(function(callback) {
  this._castConditions();

  if (this.error()) {
    callback(this.error());
    return null;
  }

  this._applyPaths();
  this._fields = this._castFields(this._fields);

  applyGlobalMaxTimeMS(this.options, this.model);

  // don't pass in the conditions because we already merged them in
  // Query.base.findOne.call(this, {}, (err, doc) => {
  //   if (err) {
  //     callback(err);
  //     return null;
  //   }

  //   this._completeOne(doc, null, _wrapThunkCallback(this, callback));
  // });

  console.log("faking FINDONE");
  const doc = new  this.model({
    protein: "shimgoose",
    spicy: true,
  });

  this._completeOne(doc, null, _wrapThunkCallback(this, callback));
});

mongoose.Model.prototype.$__handleSave = function(options, callback) {
  const _this = this;

  if (this.$isNew) {
    const obj = this.toObject();
    if ((obj || {})._id === void 0) {
      // documents must have an _id else mongoose won't know
      // what to update later if more changes are made. the user
      // wouldn't know what _id was generated by mongodb either
      // nor would the ObjectId generated by mongodb necessarily
      // match the schema definition.
      immediate(function() {
        callback(new MongooseError('document must have an _id before saving'));
      });
      return;
    }

    this.$__version(true, obj);

    console.log("faking INSERT");
    callback(null, {
      insertedCount: 1,
      ops: [{
        _id: obj._id,
        ...obj
      }]
    });

    this.$__reset();
    _setIsNew(this, false);
    // Make it possible to retry the insert
    this.$__.inserting = true;
  } else {
    // Make sure we don't treat it as a new object on error,
    // since it already exists
    this.$__.inserting = false;

    const delta = this.$__delta();
    if (delta) {
      if (delta instanceof MongooseError) {
        callback(delta);
        return;
      }

      const where = this.$__where(delta[0]);
      if (where instanceof MongooseError) {
        callback(where);
        return;
      }

      _applyCustomWhere(this, where);
      console.log("faking UPDATE");
      callback(null, {
        matchedCount: 1,
        modifiedCount: 1,
        upsertedCount: 0,
        ops: [{
          _id: this._id,
          ...delta[0]
        }]
      });
    } else {
      const optionsWithCustomValues = Object.assign({}, options, null);
      const where = this.$__where();
      if (this.$__schema.options.optimisticConcurrency) {
        const key = this.$__schema.options.versionKey;
        const val = this.$__getValue(key);
        if (val != null) {
          where[key] = val;
        }
      }
      this.constructor.exists(where, optionsWithCustomValues)
        .then(documentExists => {
          const matchedCount = !documentExists ? 0 : 1;
          callback(null, { $where: where, matchedCount });
        })
        .catch(callback);
      return;
    }

    // store the modified paths before the document is reset
    this.$__.modifiedPaths = this.modifiedPaths();
    this.$__reset();

    _setIsNew(this, false);
  }
};


function _setIsNew(doc, val) {
  doc.$isNew = val;
  doc.$emit('isNew', val);
  doc.constructor.emit('isNew', val);

  const subdocs = doc.$getAllSubdocs();
  for (const subdoc of subdocs) {
    subdoc.$isNew = val;
  }
}

function _wrapThunkCallback(query, cb) {
  return function(error, res) {
    if (error != null) {
      return cb(error);
    }

    for (const fn of query._transforms) {
      try {
        res = fn(res);
      } catch (error) {
        return cb(error);
      }
    }

    return cb(null, res);
  };
}

module.exports = {};
