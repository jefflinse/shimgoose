const mongoose = require('mongoose');
const MongooseError = require('./node_modules/mongoose/lib/error/mongooseError');
const applyGlobalMaxTimeMS = require('./node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS');
const wrapThunk = require('./node_modules/mongoose/lib/helpers/query/wrapThunk');

let modelShimFunctions = {};

// Registers CRUD functions for a given model to be called in place of MongoDB calls.
// Each function should return a promise.
//
// Example:
//
// shimgoose.registerModelShims('Taco', {
//   getOne: myFindFunc,
//   create: myCreateFunc,
//   update: myUpdateFunc,
//   delete: myDeleteFunc,
// });
function registerModelShims(modelName, funcMap) {
  modelShimFunctions[modelName] = funcMap
}

mongoose.Query.prototype._findOne = wrapThunk(function(callback) {
  this._castConditions();

  if (this.error()) {
    callback(this.error());
    return null;
  }

  this._applyPaths();
  this._fields = this._castFields(this._fields);

  applyGlobalMaxTimeMS(this.options, this.model);

  // ORIGINAL MONGOOSE LOGIC

  // don't pass in the conditions because we already merged them in
  // Query.base.findOne.call(this, {}, (err, doc) => {
  //   if (err) {
  //     callback(err);
  //     return null;
  //   }

  //   this._completeOne(doc, null, _wrapThunkCallback(this, callback));
  // });

  // SHIMMED LOGIC
  if (modelShimFunctions.hasOwnProperty(this.mongooseCollection.modelName)) {
    const funcs = modelShimFunctions[this.mongooseCollection.modelName];
    funcs['getOne'](this._conditions._id)
      .then(doc => {
        this._completeOne(doc, null, _wrapThunkCallback(this, callback));
      })
      .catch(err => {
        callback(err);
        return null;
      });
  } else {
    callback(new Error(`findOne() shim missing for ${this.mongooseCollection.modelName}`));
    return null
  }
});

mongoose.Model.prototype.$__handleSave = function(options, callback) {
  const _this = this;

  if (this.$isNew) {
    const obj = this.toObject();
    if ((obj || {})._id === void 0) {
      // documents must have an _id else mongoose won't know
      // what to update later if more changes are made. the user
      // wouldn't know what _id was generated by mongodb either
      // nor would the ObjectId generated by mongodb necessarily
      // match the schema definition.
      immediate(function() {
        callback(new MongooseError('document must have an _id before saving'));
      });
      return;
    }

    this.$__version(true, obj);

    // ORIGINAL MONGOOSE LOGIC

    // this[modelCollectionSymbol].insertOne(obj, saveOptions, function(err, ret) {
    //   if (err) {
    //     _setIsNew(_this, true);

    //     callback(err, null);
    //     return;
    //   }

    //   callback(null, ret);
    // });

    // SHIMMED LOGIC
    if (modelShimFunctions.hasOwnProperty(this.__proto__.collection.modelName)) {
      const funcs = modelShimFunctions[this.__proto__.collection.modelName];
      const obj = this.toObject();
      funcs['create'](obj)
        .then(doc => {
          callback(null, {
            insertedCount: 1,
            ops: [{
              _id: obj._id,
              ...obj
            }]
          });
        })
        .catch(err => {
          _setIsNew(_this, true);
          callback(err, null);
          return;
        });
    } else {
      callback(new Error(`create() shim missing for ${this.__proto__.collection.modelName}`));
      return null
    }

    this.$__reset();
    _setIsNew(this, false);
    // Make it possible to retry the insert
    this.$__.inserting = true;
  } else {
    // Make sure we don't treat it as a new object on error,
    // since it already exists
    this.$__.inserting = false;

    const delta = this.$__delta();
    if (delta) {
      if (delta instanceof MongooseError) {
        callback(delta);
        return;
      }

      const where = this.$__where(delta[0]);
      if (where instanceof MongooseError) {
        callback(where);
        return;
      }

      _applyCustomWhere(this, where);

      // ORIGINAL MONGOOSE LOGIC

      // this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret) => {
      //   if (err) {
      //     this.$__undoReset();

      //     callback(err);
      //     return;
      //   }
      //   ret.$where = where;
      //   callback(null, ret);
      // });

      // SHIMMED LOGIC
      if (modelShimFunctions.hasOwnProperty(this.__proto__.collection.modelName)) {
        const funcs = modelShimFunctions[this.__proto__.collection.modelName];
        const obj = this.toObject();
        funcs['update'](obj)
          .then(doc => {
            callback(null, {
              matchedCount: 1,
              modifiedCount: 1,
              upsertedCount: 0,
              ops: [{
                _id: this._id,
                ...delta[0]
              }],
              $where: where,
            });
          })
          .catch(err => {
            this.$__undoReset();
            callback(err, null);
            return;
          });
      } else {
        callback(new Error(`update() shim missing for ${this.__proto__.collection.modelName}`));
        return null
      }
    } else {
      const optionsWithCustomValues = Object.assign({}, options, null);
      const where = this.$__where();
      if (this.$__schema.options.optimisticConcurrency) {
        const key = this.$__schema.options.versionKey;
        const val = this.$__getValue(key);
        if (val != null) {
          where[key] = val;
        }
      }
      this.constructor.exists(where, optionsWithCustomValues)
        .then(documentExists => {
          const matchedCount = !documentExists ? 0 : 1;
          callback(null, { $where: where, matchedCount });
        })
        .catch(callback);
      return;
    }

    // store the modified paths before the document is reset
    this.$__.modifiedPaths = this.modifiedPaths();
    this.$__reset();

    _setIsNew(this, false);
  }
};

mongoose.Model.prototype.$__remove = function $__remove(options, cb) {
  if (this.$__.isDeleted) {
    return immediate(() => cb(null, this));
  }

  const where = this.$__where();
  if (where instanceof MongooseError) {
    return cb(where);
  }

  _applyCustomWhere(this, where);

  const session = this.$session();
  if (!options.hasOwnProperty('session')) {
    options.session = session;
  }

  // ORIGINAL MONGOOSE LOGIC

  // this[modelCollectionSymbol].deleteOne(where, options, err => {
  //   if (!err) {
  //     this.$__.isDeleted = true;
  //     this.$emit('remove', this);
  //     this.constructor.emit('remove', this);
  //     return cb(null, this);
  //   }
  //   this.$__.isDeleted = false;
  //   cb(err);
  // });

  // SHIMMED LOGIC
  if (modelShimFunctions.hasOwnProperty(this.__proto__.collection.modelName)) {
    const funcs = modelShimFunctions[this.__proto__.collection.modelName];
    funcs['delete'](this._id)
      .then(() => {
        this.$__.isDeleted = true;
        this.$emit('remove', this);
        this.constructor.emit('remove', this);
        return cb(null, this);
      })
      .catch(err => {
        this.$__.isDeleted = false;
        cb(err);
      });
  } else {
    callback(new Error(`create() shim missing for ${this.__proto__.collection.modelName}`));
    return null
  }
};

function _applyCustomWhere(doc, where) {
  if (doc.$where == null) {
    return;
  }
  for (const key of Object.keys(doc.$where)) {
    where[key] = doc.$where[key];
  }
}

function _setIsNew(doc, val) {
  doc.$isNew = val;
  doc.$emit('isNew', val);
  doc.constructor.emit('isNew', val);

  const subdocs = doc.$getAllSubdocs();
  for (const subdoc of subdocs) {
    subdoc.$isNew = val;
  }
}

function _wrapThunkCallback(query, cb) {
  return function(error, res) {
    if (error != null) {
      return cb(error);
    }

    for (const fn of query._transforms) {
      try {
        res = fn(res);
      } catch (error) {
        return cb(error);
      }
    }

    return cb(null, res);
  };
}

module.exports = {
  registerModelShims,
};
